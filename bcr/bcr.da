import sys
config(channel is fifo, clock is lamport)
from enum import Enum
import nacl.encoding
import nacl.signing
from OrderProof  import OrderProof
from OrderStatement import OrderStatement
from Crypto import Crypto

str_exp = ','
log_level =20
class State(Enum):
		PENDING=0
		IMMUTABLE=1
		ACTIVE =2
		
class Client(process):


	def setup(olympus:Olympus,clientNumber:int,signedKey:nacl.signing.SigningKey,olympusPublic:nacl.signing.SigningKey,replicaPublic:list):
		self.q = []
		self.head = None
		self.tail=None
		self.replicas = None
		self.upTime = logical_clock()
		self.count = 0
		self.signedKey = signedKey
		self.olympusPublic = olympusPublic
		self.replicaPublic= replicaPublic
	
	def run():
		c = logical_clock()
		send(('configuration_request',clientNumber), to=olympus)
		output('Client %i asking for configuration from  Olympus'%(clientNumber,), sep = str_exp, level = log_level)
		await(some(received(('configuration_response' , _, _, _, c2),from_=olympus), has = c2 >=c))
		
		key = 'movie'
		value = 'star'
		count = count+1
		c = logical_clock()
		send(('client_operation_request','put',key,value,self,count,c,clientNumber),to=head)
		output('Client %i sent request to head'%(clientNumber,), sep = str_exp, level = log_level)
		
		
		if await(some(received(('client_operation_response', 'put',result, c2,_tail)), has = c2 >=c)):
			output('Client %i received result %s from tail'%(clientNumber,result), sep = str_exp, level = log_level)
        
		elif timeout(120):
			output('Client %i timeout'%(clientNumber,), sep = str_exp, level = log_level)

		
		
		send(('done',self,clientNumber), to=parent())
		await(received(('done',), from_=parent()))
		output('client received done from master')
		output('client sending done to olympus')
		send(('done',self,clientNumber), to=olympus)
		
		
		output('Client %i terminating'%(clientNumber), sep = str_exp, level = log_level)
		
		
	def receive(msg= ('configuration_response',replicas,head,tail,c),from_=_olympus):
		output('Client %i received configuration_response from olympus'%(clientNumber,), sep = str_exp, level = log_level)
		self.head = head
		self.tail = tail
		self.replicas = replicas
		


class Olympus(process):

	
	def setup(nReplicas:int,clients:Client,olympusPrivate:nacl.signing.SigningKey,olympusPublic:nacl.signing.SigningKey,clientPublic:list,replicaPublic:list,replicaPrivate:list):
		self.head = None
		self.tail = None
		self.replicas = []
		self.olympusPrivate =olympusPrivate
		self.olympusPublic = olympusPublic
		self.clientPublic = clientPublic
		self.replicaPublic = replicaPublic
		self.replicaPrivate = replicaPrivate
		
		
	
	def run():
		output('Starting Olympus', sep = str_exp, level = log_level)
		replicas = new(Replica,num=nReplicas)
		replicas = list(replicas)
		self.head = replicas[0]
		self.tail = replicas[nReplicas-1]
		running_State = dict()
		setup(replicas,(self,State.PENDING,olympusPublic,clientPublic,replicaPublic,replicaPrivate))
		start(replicas)
		c = logical_clock()
		for i in range(nReplicas):
			send(('inithist',running_State,replicas,head,tail,i,c), to=replicas[i])
			output("Message inithist sent to replica %i" % (i,), sep = str_exp, level = log_level)
			
		
			
		await(each(client in clients, has= some(received(('done', _client,_)))))
		output('olympus received done from all clients')
		output('olympus sending  done to all replicas')
		send(('done',), to=replicas)
		await(each(replica in replicas, has= some(received(('done',_replica)))))
		output('olympus received  done from all replicas')
		send(('done',), to=parent())
		
		output('Olympus process is getting closed', sep = str_exp, level = log_level)
		
			
	def receive(msg= ('configuration_request',clientNumber),from_=p):
		output('Olympus received configuration_request from client %i' %(clientNumber,), sep = str_exp, level = log_level)
		await(each(replica in replicas, has= some(received(('inithist_response', _replica)))))
		output('Olympus sending configuration response to client %i' %(clientNumber,), sep = str_exp, level = log_level)
		send(('configuration_response',replicas,head,tail,logical_clock()), to=p)
		
	
		
class Replica(process):

	def setup(olympus:Olympus,state:State,olympusPublic:nacl.signing.SigningKey,clientPublic:list,replicaPublic:list,replicaPrivate:list):
		self.isHead = False
		self.isTail = False
		self.prevReplica = None
		self.nextReplica = None
		self.runningState = None
		self.head = None
		self.upTime = logical_clock()
		self.state = state
		self.replicaChain = None
		self.operationDict = dict()
		self.resultDict = dict()
		self.slot = -1
		self.index = -1
		self.olympusPublic = olympusPublic
		self.clientPublic = clientPublic
		self.replicaPublicList = replicaPublic
		self.replicaPrivateList = replicaPrivate
		self.replicaPrivate = None
		self.replicaPublic = None
	
	def actionsAtEveryReplica(operationName,key,value,operationId,client):
		result = None
		
		if(operationName == 'put'):
			runningState[key] = value
			resultDict[(operationId,client)] = 'OK'
			
		output('state after action %s'%(runningState,), sep = str_exp, level = log_level)
			
		
		
	
	def run():
		output('Starting Replica', sep = str_exp, level = log_level)
		-- yieldInitHist
		await(some(received(('inithist' , _, _, _, _, _, c2),from_=olympus)))
		
		await(received(('done',), from_=olympus))
		output('replica received  done from olympus')
		send(('done',self), to=olympus)
		output('replica send  done to olympus')
		
		
		
	def receive(msg= ('client_operation_request',operationName,key,value,client,operationId,logical_Clock,clientNumber)):
		
		output('Replica %i received operation request from client %i '%(index,clientNumber), sep = str_exp, level = log_level)
		orderProof = None
		if(isHead):
			slot = slot +1
			orderProof = [slot,operationName,operationId,[]]
			
		orderSt = ",".join([str(slot),operationName,str(operationId)])
		signedOrderStatement = replicaPrivate.sign(orderSt.encode())
		orderProof[3].append(signedOrderStatement)
	
		
		actionsAtEveryReplica(operationName,key,value,operationId,client)
			
		send(('forward_shuttle',operationName,key,value,client,operationId,slot,orderProof),to = nextReplica)
		
		
		
	def receive(msg= ('forward_shuttle',operationName,key,value,client,operationId,slot,orderProof),from_=_prevReplica):
		output('Replica %i received forward shuttle'%(index,), sep = str_exp, level = log_level)
		actionsAtEveryReplica(operationName,key,value,operationId,client)
		
		output('order proof is :%s'%(str(orderProof),),sep = str_exp, level = log_level)
		
		if(isTail):
			response = resultDict[(operationId,client)]
			send(('client_operation_response',operationName,response,logical_clock(),self),to = client)
		else:
			send(('forward_shuttle',operationName,key,value,client,operationId,slot),to = nextReplica)
		
	def receive(msg= ('inithist',running_State,replicas,head,tail,index,c),from_=_olympus,at=(yieldInitHist,)):
		
		self.head = head
		runningState = running_State
		self.replicaChain = replicas
		self.index = index
		self.replicaPrivate = replicaPrivateList[index]
	 	#self.replicaPublic = replicaPublicList[index]
		
		if(index == 0):
			isHead = True
			nextReplica = replicaChain[index+1]
			output("Replica %i is head" % (index,), sep = str_exp, level = log_level)
	 		
		elif(index == len(replicaChain)-1):
			isTail =True
			prevReplica = replicaChain[index-1]
			output("Replica %i is tail" % (index,), sep = str_exp, level = log_level)
		else:
			prevReplica = replicaChain[index-1]
			nextReplica = replicaChain[index+1]
		state = State.ACTIVE
		output('replica %i received inithist from olympus'%(index,), sep = str_exp, level = log_level)
		send(('inithist_response',self),to = olympus)
		
	 	
def main():
	nclients = int(sys.argv[1]) if len(sys.argv) > 1 else 2
	nReplicas = int(sys.argv[2]) if len(sys.argv) > 1 else 2
	config(clock='Lamport')
	crypto = Crypto()
	(olympusPrivate,olympusPublic) = crypto.getSignedKey()
	clientPrivate = []
	clientPublic = []
	replicaPrivate = []
	replicaPublic = []
	
	for i in range(nclients):
		(private,public)= crypto.getSignedKey()
		clientPrivate.append(private)
		clientPublic.append(public)
		
	for i in range(nReplicas):
		(private,public)= crypto.getSignedKey()
		replicaPrivate.append(private)
		replicaPublic.append(public)
		
		
		
	
	clients = new(Client,num=nclients)
	clients = list(clients)
	
	olympus = new(Olympus,num= 1)
	for i in range(nclients):
		setup(clients[i],(olympus,i,clientPrivate[i],olympusPublic,replicaPublic))
	
	setup(olympus, (nReplicas,clients,olympusPrivate,olympusPublic,clientPublic,replicaPublic,replicaPrivate))
	start(olympus)
	start(clients)
	
	await(each(client in clients, has= some(received(('done', _client,_)))))
	output('master receiveded done from all clients', sep = str_exp, level = log_level)
	send(('done',), to=clients)
	output('master acknowledge done to clients')
	output('master waiting  done from  olympus')
	#await(received(('done',), from_=olympus))
	
	await(some(received(('done',), from_=olympus)))
	output('master received  done from  olympus')
	
	

	